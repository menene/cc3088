<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transacciones</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/theme/black.min.css">
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- Slide 1: Portada -->
            <section>
                <h2>Transacciones</h2>
                <p>Semestre 1, 2025</p>
            </section>

            <!-- Slide 2: Introducci√≥n a las Transacciones -->
            <section>
                <section><h2>¬øQu√© es una Transacci√≥n?</h2></section>
                <section><p>Una transacci√≥n es una unidad l√≥gica de trabajo en una base de datos que agrupa una o m√°s operaciones que deben ejecutarse de manera at√≥mica.</p></section>
                <section><p>Son fundamentales para garantizar la integridad de los datos y el manejo seguro de operaciones que involucran m√∫ltiples modificaciones.</p></section>
                <section><h3>¬øPor qu√© son importantes?</h3></section>
                <section><ul>
                    <li>Garantizan la consistencia de los datos en sistemas cr√≠ticos.</li>
                </ul></section>
                <section><ul>
                    <li>Permiten el manejo seguro de operaciones complejas.</li>
                </ul></section>
                <section><ul>
                    <li>Recuperan el estado ante errores.</li>
                </ul></section>
                <section><ul>
                    <li>Se usan en sistemas financieros, comercio electr√≥nico y aplicaciones empresariales.</li>
                </ul></section>
                <section><h3>Ejemplos comunes de uso</h3></section>
                <section><ul>
                    <li>üè¶ Transferencias bancarias.</li>
                </ul></section>
                <section><ul>
                    <li>üì¶ Actualizaci√≥n de inventarios.</li>
                </ul></section>
                <section><ul>
                    <li>üßæ Procesos de facturaci√≥n.</li>
                </ul></section>
            </section>

            <!-- Slide 3: Propiedades ACID -->
            <section>
                <section><h2>ACID</h2></section>
                <section><h3>¬øQu√© es ACID?</h3>
                    <p>El t√©rmino ACID es un acr√≥nimo que describe las propiedades fundamentales que debe cumplir una transacci√≥n en una base de datos para garantizar la integridad y consistencia de los datos.</p>
                </section>
                <section>
                    <p>Estas propiedades son esenciales en sistemas de gesti√≥n de bases de datos relacionales como PostgreSQL, donde el manejo seguro y coherente de los datos es una prioridad.</p>
                </section>
                <section>
                    <p>ACID garantiza que las operaciones realizadas en una transacci√≥n se completen de manera confiable, incluso en situaciones de fallos del sistema o concurrencia.</p>
                </section>
                <section><h3>ACID en Bases de Datos</h3>
                    <p>Las transacciones en sistemas de bases de datos son secuencias de operaciones que se ejecutan como una sola unidad l√≥gica. Para que una transacci√≥n se considere segura, debe cumplir con las siguientes propiedades:</p>
                </section>
                <section>
                    <ul>
                        <li>Atomicidad</li>
                        <li>Consistencia</li>
                        <li>Aislamiento</li>
                        <li>Durabilidad</li>
                    </ul>
                </section>
                <section>
                    <h3>Atomicidad</h3>
                </section>
                <section>
                    <p>La atomicidad garantiza que todas las operaciones de una transacci√≥n se realicen por completo o no se realice ninguna. Si alguna operaci√≥n falla, el sistema debe asegurarse de que no se apliquen cambios parciales.</p>
                </section>
                <section>
                    <p>Ejemplo: En una transferencia bancaria, si se descuenta el dinero de una cuenta pero no se acredita en la otra, el sistema debe revertir la transacci√≥n para evitar inconsistencias.</p>
                </section>
                <section>
                    <p>Comandos relacionados: <code>BEGIN</code>, <code>COMMIT</code>, <code>ROLLBACK</code>.</p>
                </section>
                <section>
                    <h3>Consistencia</h3>
                </section>
                <section>
                    <p>La consistencia garantiza que una transacci√≥n lleve la base de datos de un estado v√°lido a otro estado v√°lido, respetando todas las reglas de integridad y restricciones.</p>
                </section>
                <section>
                    <p>Ejemplo: Si en una tabla de cuentas bancarias el saldo no puede ser negativo, una transacci√≥n que provoque esta situaci√≥n debe fallar para mantener la consistencia.</p>
                </section>
                <section>
                    <p>La consistencia tambi√©n se refiere a mantener integridad referencial, restricciones de unicidad y validaciones l√≥gicas.</p>
                </section>
                <section>
                    <h3>Aislamiento</h3>
                </section>
                <section>
                    <p>El aislamiento garantiza que las transacciones concurrentes no interfieran entre s√≠, de modo que el resultado final sea el mismo que si se ejecutaran secuencialmente.</p>
                </section>
                <section>
                    <p>PostgreSQL maneja el aislamiento a trav√©s de niveles, desde el m√°s permisivo (Read Uncommitted) hasta el m√°s restrictivo (Serializable).</p>
                </section>
                <section>
                    <p>Ejemplo: Si dos usuarios intentan modificar el mismo registro al mismo tiempo, el sistema debe garantizar que solo uno de los cambios sea persistido.</p>
                </section>
                <section>
                    <h3>Durabilidad</h3>
                </section>
                <section>
                    <p>La durabilidad asegura que, una vez que una transacci√≥n se ha confirmado (COMMIT), los cambios persistan permanentemente en el almacenamiento, incluso si ocurre un fallo del sistema inmediatamente despu√©s.</p>
                </section>
                <section>
                    <p>Ejemplo: Si una transacci√≥n registra una venta y se confirma, el registro debe mantenerse aun si el servidor se apaga posteriormente.</p>
                </section>
                <section>
                    <p>PostgreSQL asegura la durabilidad utilizando el registro WAL (Write-Ahead Logging), que garantiza que los cambios se escriban en el almacenamiento antes de confirmarlos.</p>
                </section>
            </section>

            <section>
                <section><h2>Comandos B√°sicos</h2></section>
                <section><h3>BEGIN, COMMIT, ROLLBACK</h3>
                    <p>Los comandos b√°sicos para manejar transacciones en PostgreSQL son:</p>
                </section>
                <section>
                    <ul>
                        <li><strong>BEGIN:</strong> Inicia una nueva transacci√≥n. Permite agrupar m√∫ltiples sentencias SQL como una sola unidad de trabajo.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>COMMIT:</strong> Finaliza la transacci√≥n y guarda todos los cambios realizados.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>ROLLBACK:</strong> Revierte todos los cambios realizados durante la transacci√≥n si ocurre un error o se decide cancelar.</li>
                    </ul>
                </section>
                <section>
                    <h3>Ejemplo: Actualizaci√≥n de saldo en una cuenta bancaria</h3>
                </section>
                <section>
                    <p>Supongamos que queremos transferir 100 unidades de la cuenta 1 a la cuenta 2. Si ocurre un error, revertiremos la operaci√≥n.</p>
                </section>
                <section>
                    <pre><code class="sql">
-- Iniciar la transacci√≥n
BEGIN;

-- Restar 100 unidades de la cuenta 1
UPDATE cuentas SET saldo = saldo - 100 WHERE id = 1;

-- Sumar 100 unidades a la cuenta 2
UPDATE cuentas SET saldo = saldo + 100 WHERE id = 2;

-- Confirmar los cambios
COMMIT;
                                            </code></pre>
                </section>
                <section>
                    <h3>Ejemplo: Uso de ROLLBACK</h3>
                </section>
                <section>
                    <p>Si se detecta un error durante el proceso, usamos <strong>ROLLBACK</strong> para revertir los cambios.</p>
                </section>
                <section>
                    <pre><code class="sql">
BEGIN;

-- Intento de transferencia
UPDATE cuentas SET saldo = saldo - 100 WHERE id = 1;

-- Verificar si el saldo es negativo
SELECT saldo FROM cuentas WHERE id = 1;

-- Si el saldo es negativo, revertir la transacci√≥n
ROLLBACK;

COMMIT;
                    </code></pre>
                </section>
            </section>
            

            <!-- Slide 5: Manejo de Errores y Rollback -->
            <section>
                <section><h2>Manejo de Errores con SAVEPOINT</h2></section>
                <section><p>Uso de SAVEPOINT para rollback parcial en transacciones complejas.</p></section>
                <section><pre><code class="sql">
BEGIN;
SAVEPOINT sp1;
INSERT INTO ventas (producto, cantidad) VALUES ('Libro', 10);
ROLLBACK TO sp1;
COMMIT;
                    </code></pre>
                </section>
            </section>

            <!-- Slide 7: Problemas de Concurrencia -->
            <section>
                <section>
                    <h2>Problemas de Concurrencia</h2>
                </section>
                <section>
                    <ul>
                        <li>Lectura sucia</li>
                        <li>Lectura no repetible</li>
                        <li>Lectura fantasma</li>
                    </ul>
                </section>
                <section>
                    <h3>Lectura Sucia (Dirty Read)</h3>
                </section>
                <section>
                    <p>Ocurre cuando una transacci√≥n lee datos que a√∫n no han sido confirmados por otra transacci√≥n. Si la transacci√≥n que escribi√≥ los datos hace un rollback, el valor le√≠do queda inv√°lido.</p>
                </section>
                <section>
                    <h3>Lectura No Repetible (Non-Repeatable Read)</h3>
                </section>
                <section>
                    <p>Ocurre cuando una transacci√≥n vuelve a leer un dato y encuentra que este ha cambiado debido a otro COMMIT realizado en otra transacci√≥n.</p>
                </section>
                <section>
                    <h3>Lectura Fantasma (Phantom Read)</h3>
                </section>
                <section>
                    <p>Ocurre cuando nuevas filas que cumplen la condici√≥n de la consulta son a√±adidas por otra transacci√≥n durante la ejecuci√≥n de la transacci√≥n actual.</p>
                </section>
            </section>


            <!-- niveles de aislamiento -->
            <section>
                <section><h2>Niveles de Aislamiento</h2></section>
            
                <!-- Read Uncommitted -->
                <section>
                    <h3>Read Uncommitted</h3>
                </section>
                <section>
                    <p>Permite leer datos no confirmados por otras transacciones.</p>
                    <p>Es el nivel de aislamiento m√°s bajo y menos seguro.</p>
                </section>
                <section>
                    <h4>Problema: Lectura Sucia (Dirty Read)</h4>
                </section>
            
                <!-- Read Committed -->
                <section>
                    <h3>Read Committed</h3>
                </section>
                <section>
                    <p>Solo permite leer datos que han sido confirmados por otras transacciones.</p>
                    <p>Es el nivel de aislamiento predeterminado en PostgreSQL.</p>
                </section>
                <section>
                    <h4>Problema: Lectura No Repetible (Non-Repeatable Read)</h4>
                </section>
            
                <!-- Repeatable Read -->
                <section>
                    <h3>Repeatable Read</h3>
                </section>
                <section>
                    <p>Evita lecturas no repetibles al garantizar que el conjunto de datos consultados no cambie durante la transacci√≥n.</p>
                </section>
                <section>
                    <h4>Problema: Lectura Fantasma (Phantom Read)</h4>
                </section>
            
                <!-- Serializable -->
                <section>
                    <h3>Serializable</h3>
                </section>
                <section>
                    <p>Es el nivel de aislamiento m√°s alto, garantiza que las transacciones se ejecuten como si fueran secuenciales.</p>
                    <p>Evita tanto lecturas sucias como no repetibles y lecturas fantasma.</p>
                </section>
            
                <!-- Comparaci√≥n de Niveles -->
                <section>
                    <h3>Comparaci√≥n de Niveles de Aislamiento</h3>
                    <table style="font-size: 20px;">
                        <tr>
                            <th>Nivel</th>
                            <th>Lectura Sucia</th>
                            <th>Lectura No Repetible</th>
                            <th>Lectura Fantasma</th>
                        </tr>
                        <tr>
                            <td>Read Uncommitted</td>
                            <td>‚úÖ</td>
                            <td>‚úÖ</td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td>Read Committed</td>
                            <td>‚ùå</td>
                            <td>‚úÖ</td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td>Repeatable Read</td>
                            <td>‚ùå</td>
                            <td>‚ùå</td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td>Serializable</td>
                            <td>‚ùå</td>
                            <td>‚ùå</td>
                            <td>‚ùå</td>
                        </tr>
                    </table>
                </section>
            </section>

            <!-- bloqueo -->
            <section>
                <section><h2>Estrategias de Bloqueo</h2></section>
            
                <!-- Introducci√≥n a Bloqueos -->
                <section>
                    <p>El bloqueo es una t√©cnica que garantiza la integridad y consistencia de los datos cuando m√∫ltiples transacciones intentan acceder simult√°neamente a los mismos recursos.</p>
                </section>
                <section>
                    <p>PostgreSQL utiliza varios tipos de bloqueos para evitar conflictos de concurrencia.</p>
                </section>
                <section>
                    <p>Los bloqueos se pueden aplicar a nivel de fila o tabla, dependiendo del alcance de la operaci√≥n.</p>
                </section>
            
                <!-- Bloqueo de Fila -->
                <section>
                    <h3>Bloqueo de Fila (Row-Level Lock)</h3>
                </section>
                <section>
                    <p>Este tipo de bloqueo permite restringir el acceso a una fila espec√≠fica de una tabla mientras se realiza una operaci√≥n.</p>
                </section>
                <section>
                    <p>Es √∫til para evitar conflictos en operaciones que actualizan registros individuales.</p>
                </section>
                <section>
                    <p>PostgreSQL utiliza bloqueos de fila de forma autom√°tica en operaciones como <code>UPDATE</code> o <code>DELETE</code>.</p>
                </section>
                <section>
                    <h4>Tipos de Bloqueo de Fila</h4>
                </section>
                <section>                    
                    <ul>
                        <li><strong>FOR UPDATE:</strong> Bloquea la fila para actualizaci√≥n. Evita que otros la modifiquen.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>FOR NO KEY UPDATE:</strong> Similar al anterior, pero permite modificaciones en otros campos que no son claves.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>FOR SHARE:</strong> Permite la lectura compartida, pero no la modificaci√≥n.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>FOR KEY SHARE:</strong> Permite actualizar claves for√°neas, pero no los datos directamente.</li>
                    </ul>
                </section>
                <section>
                    <h4>Ejemplo: Bloqueo de Fila</h4>
                    <pre><code class="sql">
-- Transacci√≥n 1: Bloqueo de fila para actualizaci√≥n
BEGIN;
SELECT * FROM cuentas WHERE id = 1 FOR UPDATE;

-- Transacci√≥n 2: Intento de actualizaci√≥n bloqueado
UPDATE cuentas SET saldo = saldo + 50 WHERE id = 1;

-- Confirmar los cambios
COMMIT;
                    </code></pre>
                </section>
                <section>
                    <p>En este caso, la segunda transacci√≥n queda en espera hasta que la primera complete su operaci√≥n.</p>
                </section>
            
                <!-- Bloqueo de Tabla -->
                <section>
                    <h3>Bloqueo de Tabla (Table-Level Lock)</h3>
                </section>
                <section>
                    <p>Este tipo de bloqueo se aplica a toda la tabla, restringiendo el acceso a cualquier fila dentro de ella.</p>
                </section>
                <section>
                    <p>Se utiliza cuando es necesario garantizar la integridad en operaciones que afectan m√∫ltiples filas simult√°neamente.</p>
                </section>
                <section>
                    <h4>Tipos de Bloqueo de Tabla</h4>
                </section>
                <section>
                    <ul>
                        <li><strong>ACCESS SHARE:</strong> Permite solo lectura. Utilizado en consultas (<code>SELECT</code>).</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>ROW SHARE:</strong> Permite leer mientras se realizan actualizaciones (<code>SELECT ... FOR UPDATE</code>).</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>EXCLUSIVE:</strong> Permite modificaciones sin bloqueo exclusivo.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li><strong>ACCESS EXCLUSIVE:</strong> Bloquea completamente el acceso. Se utiliza en operaciones de <code>ALTER TABLE</code>.</li>
                    </ul>
                </section>
                <section>
                    <h4>Ejemplo: Bloqueo de Tabla</h4>
                    <pre><code class="sql">
-- Transacci√≥n 1: Bloqueo exclusivo en la tabla
BEGIN;
LOCK TABLE cuentas IN EXCLUSIVE MODE;

-- Operaci√≥n que bloquea toda la tabla para modificaci√≥n
UPDATE cuentas SET saldo = saldo - 50 WHERE id = 1;

-- Otra transacci√≥n que intenta leer queda bloqueada
SELECT * FROM cuentas;

-- Confirmar cambios
COMMIT;
                    </code></pre>
                </section>
                <section>
                    <p>El bloqueo exclusivo asegura que ninguna otra transacci√≥n pueda acceder a la tabla mientras se realiza la actualizaci√≥n.</p>
                </section>
            
                <!-- Consideraciones sobre Bloqueos -->
                <section>
                    <h3>Consideraciones sobre el Uso de Bloqueos</h3>
                </section>
                <section>
                    <ul>
                        <li>Usar bloqueos de fila cuando el impacto es solo en registros individuales.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Optar por bloqueos de tabla solo cuando se requiera garantizar la integridad en operaciones masivas.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Bloqueos excesivos pueden causar problemas de rendimiento y cuellos de botella.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Usar expl√≠citamente el comando <code>LOCK</code> solo cuando el manejo autom√°tico no sea suficiente.</li>
                    </ul>
                </section>
            </section>

            <section>
                <section><h2>Cambiar los Niveles de Bloqueo</h2></section>
            
                <!-- Introducci√≥n -->
                <section>
                    <h3>¬øEs posible cambiar los niveles de bloqueo?</h3>
                </section>
                <section>
                    <p>En PostgreSQL, no se pueden cambiar directamente los niveles de bloqueo predeterminados a nivel de DBMS.</p>
                </section>
                <section>
                    <p>El sistema de bloqueo est√° dise√±ado para ajustarse de manera √≥ptima seg√∫n el tipo de operaci√≥n que se realiza.</p>
                </section>
            
                <!-- Cambiar el Nivel de Aislamiento por Defecto -->
                <section>
                    <h3>Nivel de Aislamiento Predeterminado</h3>
                </section>
                <section>
                    <p>En lugar de cambiar los niveles de bloqueo directamente, se puede modificar el <b>nivel de aislamiento predeterminado</b> para afectar el comportamiento del bloqueo.</p>
                </section>
                <section>
                    <pre><code class="sql">
ALTER DATABASE nombre_base_de_datos 
SET default_transaction_isolation TO 'serializable';
                    </code></pre>
                </section>
                <section>
                    <p>Esto har√° que todas las transacciones usen el nivel <code>SERIALIZABLE</code> si no se especifica expl√≠citamente otro.</p>
                </section>
            
                <!-- Consideraciones -->
                <section>
                    <h3>Consideraciones</h3>
                </section>
                <section>
                    <ul>
                        <li>El cambio afecta a todas las conexiones que no especifiquen un nivel expl√≠cito.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Algunos niveles, como <code>READ UNCOMMITTED</code>, no est√°n soportados en PostgreSQL por razones de integridad.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>El nivel <code>SERIALIZABLE</code> garantiza la m√°xima consistencia pero puede afectar el rendimiento.</li>
                    </ul>
                </section>
            
                <!-- Alternativa: Especificar el Nivel en la Transacci√≥n -->
                <section>
                    <h3>Especificar el Nivel en la Transacci√≥n</h3>
                </section>
                <section>
                    <p>Una alternativa m√°s controlada es definir el nivel de aislamiento directamente en la transacci√≥n:</p>
                </section>
                <section>
                    <pre><code class="sql">
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- Operaciones SQL
COMMIT;
                    </code></pre>
                </section>
                <section>
                    <p>Esto garantiza que solo esa transacci√≥n use el nivel de aislamiento deseado, sin afectar las dem√°s.</p>
                </section>
            </section>
            
            

            <section>
                <section><h2>Transacciones Anidadas</h2></section>
            
                <!-- ¬øQu√© son las Transacciones Anidadas? -->
                <section>
                    <h3>¬øQu√© son las Transacciones Anidadas?</h3>
                </section>
                <section>
                    <p>Las transacciones anidadas son transacciones que se ejecutan dentro de otra transacci√≥n.</p>
                </section>
                <section>
                    <p>En PostgreSQL, no existen transacciones completamente anidadas como en otros sistemas, pero se pueden simular usando <strong>SAVEPOINT</strong>.</p>
                </section>
                <section>
                    <p>Los <strong>SAVEPOINT</strong> permiten crear puntos de control dentro de una transacci√≥n, facilitando la reversi√≥n parcial sin afectar toda la transacci√≥n principal.</p>
                </section>
            
                <!-- ¬øPor qu√© usar Transacciones Anidadas? -->
                <section>
                    <h3>¬øPor qu√© usar Transacciones Anidadas?</h3>
                </section>
                <section>
                    <ul>
                        <li>Permiten realizar m√∫ltiples operaciones relacionadas dentro de una transacci√≥n mayor.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Facilitan el manejo de errores en procesos complejos, donde solo algunas partes pueden fallar.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Garantizan la integridad de datos cuando algunas operaciones pueden revertirse sin afectar el resto.</li>
                    </ul>
                </section>
            
                <!-- Uso de SAVEPOINT -->
                <section>
                    <h3>Uso de SAVEPOINT en Transacciones Anidadas</h3>
                </section>
                <section>
                    <p>El comando <code>SAVEPOINT</code> crea un punto de control dentro de la transacci√≥n, mientras que <code>ROLLBACK TO</code> permite volver a ese punto sin cancelar toda la transacci√≥n.</p>
                </section>
                <section>
                    <p>El comando <code>RELEASE SAVEPOINT</code> elimina el punto de guardado para liberar recursos.</p>
                </section>
            
                <!-- Ejemplo de Transacci√≥n Anidada -->
                <section>
                    <h3>Ejemplo: Proceso de Facturaci√≥n</h3>
                </section>
                <section>
                    <p>Supongamos que queremos registrar un pedido con m√∫ltiples productos. Si alguno falla, revertimos solo ese registro, pero no todo el pedido.</p>
                </section>
                <section>
                    <pre><code class="sql" style="font-size: 14px;">
BEGIN;

-- Registrar el pedido principal
INSERT INTO pedidos (cliente_id, fecha) VALUES (1, NOW());

-- Crear un punto de guardado para el primer producto
SAVEPOINT producto1;
INSERT INTO pedido_detalles (pedido_id, producto_id, cantidad) VALUES (1, 101, 5);

-- Si falla el primer producto, revertir solo esa parte
ROLLBACK TO producto1;

-- Registrar el segundo producto
SAVEPOINT producto2;
INSERT INTO pedido_detalles (pedido_id, producto_id, cantidad) VALUES (1, 102, 3);

-- Confirmar los cambios del segundo producto
RELEASE SAVEPOINT producto2;

-- Finalizar la transacci√≥n principal
COMMIT;
                    </code></pre>
                </section>
                <section>
                    <p>Si el registro del primer producto falla, solo esa parte se revierte, pero el pedido y otros productos se mantienen.</p>
                </section>
            
                <!-- Ventajas y Desventajas -->
                <section>
                    <h3>Ventajas de las Transacciones Anidadas</h3>
                </section>
                <section>
                    <ul>
                        <li>Mayor control en operaciones complejas.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Permite revertir solo partes espec√≠ficas sin perder toda la transacci√≥n.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Facilita el manejo de errores parciales.</li>
                    </ul>
                </section>
                <section>
                    <h3>Desventajas y Consideraciones</h3>
                </section>
                <section>
                    <ul>
                        <li>Uso excesivo puede hacer el c√≥digo complejo y dif√≠cil de mantener.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>No garantiza que todos los sistemas interpreten el rollback parcial de la misma manera.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Si no se usa correctamente, puede generar inconsistencias si se omite el <code>RELEASE</code>.</li>
                    </ul>
                </section>
            
                <!-- Buenas Pr√°cticas -->
                <section>
                    <h3>Buenas Pr√°cticas</h3>
                </section>
                <section>
                    <ul>
                        <li>Definir puntos de guardado solo cuando realmente sean necesarios.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Usar nombres descriptivos para los <code>SAVEPOINT</code> para facilitar el mantenimiento.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Liberar los puntos de guardado que ya no se necesiten con <code>RELEASE SAVEPOINT</code>.</li>
                    </ul>
                </section>
                <section>
                    <ul>
                        <li>Evitar el uso anidado excesivo, ya que puede llevar a transacciones complejas y propensas a errores.</li>
                    </ul>
                </section>
            </section>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script>
        Reveal.initialize();
    </script>
</body>
</html>